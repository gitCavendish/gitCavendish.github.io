<!DOCTYPE html>
<!--
    So Simple Jekyll Theme 3.2.0
    Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
-->
<html lang="en-US" class="no-js">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>On exploring Promise 2: possible overlooked points about promise | Xullnn’s words</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="On exploring Promise 2: possible overlooked points about promise" />
<meta name="author" content="Xullnn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="尝试更好的理解web开发中 Promise 这个工具，第二部分。" />
<meta property="og:description" content="尝试更好的理解web开发中 Promise 这个工具，第二部分。" />
<link rel="canonical" href="http://localhost:4000/work/promise2-key-points/" />
<meta property="og:url" content="http://localhost:4000/work/promise2-key-points/" />
<meta property="og:site_name" content="Xullnn’s words" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-28T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="On exploring Promise 2: possible overlooked points about promise" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@Xullnn" />
<script type="application/ld+json">
{"datePublished":"2020-08-28T00:00:00+08:00","headline":"On exploring Promise 2: possible overlooked points about promise","dateModified":"2020-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/work/promise2-key-points/"},"url":"http://localhost:4000/work/promise2-key-points/","author":{"@type":"Person","name":"Xullnn"},"description":"尝试更好的理解web开发中 Promise 这个工具，第二部分。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  

  <script>
    /* Cut the mustard */
    if ( 'querySelector' in document && 'addEventListener' in window ) {
      document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + 'js';
    }
  </script>

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/skins/dark.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i|Lora:400,400i,700,700i">
  <link rel="alternate" type="application/atom+xml" title="Xullnn&#39;s words" href="/atom.xml">
<!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

</head>


  <body class="layout--post  on-exploring-promise-2-possible-overlooked-points-about-promise">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#primary-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    
  <div class="navigation-wrapper">
    <a href="#menu-toggle" id="menu-toggle">Menu</a>
    <nav id="primary-nav" class="site-nav animated drop">
      <ul><li><a href="/">Home</a></li><li><a href="/categories/">Categories</a></li><li><a href="/tags/">Tags</a></li><li><a href="/search/">Search</a></li></ul>
    </nav>
  </div><!-- /.navigation-wrapper -->


    <header class="masthead">
  <div class="wrap">
    
    
    
      
        <div class="site-title animated fadeIn"><a href="/">Xullnn's words</a></div>
      
      <p class="site-description animated fadeIn" itemprop="description">You can't do much carpentry with your bare hands and you can't do much thinking with your bare brain.</p>
    
  </div>
</header><!-- /.masthead -->


    <main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

    <div class="page-wrapper">
      <header class="page-header">
        
        
          <h1 id="page-title" class="page-title p-name">On exploring Promise 2: possible overlooked points about promise
</h1>
        
      </header>

      <div class="page-sidebar">
        <div class="page-author h-card p-author"><img src="/images/2020.jpg" class="author-avatar u-photo" alt="Xullnn"><div class="author-info"><div class="author-name">
        <em>by</em> <span class="p-name">Xullnn</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href=""><i class="fas fa-link fa-lg" title=""></i></a>
          </li></ul>

<span class="read-time">14 min read</span>

    <time class="page-date dt-published" datetime="2020-08-28T00:00:00+08:00"><a class="u-url" href="">August 28, 2020</a>
</time>

  </div>
</div>

        
  <h3 class="page-taxonomies-title">Categories</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="/categories/#work" title="Pages filed under Work">Work</a></li>
  </ul>


        
  <h3 class="page-taxonomies-title">Tags</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a href="/tags/#programming" title="Pages tagged programming" rel="tag">programming</a></li>
  </ul>


      </div>

      <div class="page-content">
        <div class="e-content">
          <p>尝试更好的理解web开发中 Promise 这个工具，第二部分。</p>

<p>This is part 2 of my exploring on promise. In part 1, I shared my thoughts about “async” and “event loop” as the basis to better understand promise. The main purpose of this part is share some points or say “blind spots” about promise that may impede your understanding of promise.</p>

<p>After a brief introduction about basic aspects of promise, I’ll share a few links for learning how to use promise. Because have a basic sense about what is promise and how to use it is important for the main discussion in this article. You don’t have to master “promise” after the studies, otherwise there wouldn’t have been this article. I believe many beginners will leave mental gaps after being introduced with promise. Some key points are somehow omitted by most learning materials. Maybe they are too obvious to pros, but
not so obvious to newbies. It’s more of a communication problem. I hope this article can help you recognize a few of these points and help you connect the dots from “async” to “promise”.</p>

<p><strong>Terms in this article</strong></p>

<p>Based on different contexts, the word “promise” has different meanings, most of the difference can be distinguished with different writing forms but there’re a few subtle ones may not be easily distinguished. In this post “promise” may in the forms of:</p>

<ul>
  <li>plain lowercase “promise”: the general concept of promise</li>
  <li>code quoted lowercase <code class="language-plaintext highlighter-rouge">promise</code>: an instance of a promise</li>
  <li>code quoted uppercase <code class="language-plaintext highlighter-rouge">Promise</code>: the <code class="language-plaintext highlighter-rouge">Promise</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise">constructor</a></li>
</ul>

<p>And <code class="language-plaintext highlighter-rouge">resolve(d)</code> and <code class="language-plaintext highlighter-rouge">fulfill(ed)</code> are used interchangeably.</p>

<h3 id="1-basic-aspects-aboutpromise">1 Basic aspects about promise</h3>

<h4 id="11-sense-of-promise">1.1 Sense of promise:</h4>

<p>I want to start with different definitions of promise. For now we don’t have to understand all the terms before we can continue. Here comes the definitions:</p>

<ul>
  <li><a href="https://promisesaplus.com/">Promise/A+</a>: A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a>: A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action’s eventual success value or failure reason.</li>
  <li><a href="https://en.wikipedia.org/wiki/Futures_and_promises">wikipedia</a>: In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program execution in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is not yet complete.</li>
</ul>

<p>So promise must have something to do with “async”, and it’s a representation/proxy for a future result. Bringing this high level sense of promise into the exploring of promise is necessary.</p>

<h4 id="12-use-of-promise">1.2 use of promise</h4>

<p>As I said, this part of work(use of promise) is excellently done by some pros, thank them a lot!</p>

<ul>
  <li>https://web.dev/promises/</li>
</ul>

<p>This article does a thorough explanation about the use of promise with code examples, along with some performance concerns. Inevitably you would come across some unacquainted terms. You can glimpse their definitions on wiki if you want to, but don’t go too deep, focus on “how to use promise” and just get a feel about it. And you may want to read it multiple times as I did.</p>

<h4 id="13-states-of-promise">1.3 States of promise</h4>

<p>Promise is like a wrapper for asynchronous operations(tasks), and it holds the result of the task and based on how things are going, it stipulates a promise can be in one of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">three states</a>:</p>

<ul>
  <li>pending: the initial state, means the task is still processing and we don’t know how things are going so far</li>
  <li>resolved: means the task is successfully fulfilled, and it may give us something we want such as data or just a message that indicates the task has succeeded.</li>
  <li>rejected: means the task failed, and reasonably a reason(often an error object) should be given to tell what was wrong</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">pending</code> is when the async operation is still processing, <code class="language-plaintext highlighter-rouge">resolved(fulfilled)</code> and <code class="language-plaintext highlighter-rouge">rejected</code> are when the async operation is completed whether succeeded or failed, when a <code class="language-plaintext highlighter-rouge">promise</code>’s state is <code class="language-plaintext highlighter-rouge">resolved(fulfilled)</code> or <code class="language-plaintext highlighter-rouge">rejected</code>, we also say it’s settled.</p>

<h3 id="2-a-few-key-points-that-may-be-overlooked">2 A few key points that may be overlooked</h3>

<p>This part mainly shares with you some key points about promise. They are not overlooked by purpose, and you may feel so strange that you haven’t noticed them. Because they are just some basic facts sit there for a long time.</p>

<h4 id="21-promise-constructor-is-used-for-creating-promise-then-method-is-used-for-accessing-promise">2.1 <code class="language-plaintext highlighter-rouge">Promise</code> constructor is used for creating promise, <code class="language-plaintext highlighter-rouge">then()</code> method is used for accessing promise</h4>

<p>There’s a concise description about the purpose of <code class="language-plaintext highlighter-rouge">Promise</code> constructor.</p>

<blockquote>
  <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise">The Promise constructor is primarily used to wrap functions that do not already support promises.</a></p>
</blockquote>

<p>After reading a lot about how to use promise, we know that <code class="language-plaintext highlighter-rouge">Promise()</code> can create a <code class="language-plaintext highlighter-rouge">promise</code> and <code class="language-plaintext highlighter-rouge">then</code> is the way to chain subsequent operations. But being aware of the original designing purpose is also important, especially when you ask question like “Since <code class="language-plaintext highlighter-rouge">Promise()</code> and <code class="language-plaintext highlighter-rouge">then()</code> both return a promise, so what’s the difference?”. Maybe we should ask a more basic question: what a constructor is used for in JavaScript?</p>

<p>The answer is when we want to create a <code class="language-plaintext highlighter-rouge">promise</code>, the <code class="language-plaintext highlighter-rouge">Promise()</code> constructor is the first choice, not <code class="language-plaintext highlighter-rouge">then()</code>.We can say <code class="language-plaintext highlighter-rouge">Promise()</code> is primarily used to wrap functions that do not already support promises. Or we can say it’s used for “Promisifying” something. And  <code class="language-plaintext highlighter-rouge">then()</code> is the way to chain promises, as well as the way to access the value of a <code class="language-plaintext highlighter-rouge">promise</code>. Though <code class="language-plaintext highlighter-rouge">then()</code> always returns a <code class="language-plaintext highlighter-rouge">promise</code>, we should not treat this behavior as its designing purpose. Seeing <code class="language-plaintext highlighter-rouge">then()</code> as the interface to access <code class="language-plaintext highlighter-rouge">promise</code>s is a more appropriate view.</p>

<h4 id="22-code-in-promise-executes-as-soon-as-the-promise-is-created">2.2 Code in <code class="language-plaintext highlighter-rouge">Promise</code> executes as soon as the promise is created</h4>

<p>I think this is an important fact but most intro level materials don’t mention. And this trapped me for a long time when I was trying to figure out how to use promise.</p>

<p><strong>the beginning of creation is the beginning of executing</strong></p>

<p>If we have a function that returns a <code class="language-plaintext highlighter-rouge">promise</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">makePromise</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// do sync thing one</span>
    <span class="c1">// do sync thing two</span>
    <span class="c1">// resolve or reject at a certain point</span>
  <span class="p">})</span>
<span class="p">};</span>
</code></pre></div></div>

<p>When you execute <code class="language-plaintext highlighter-rouge">makePromise()</code>, <code class="language-plaintext highlighter-rouge">thing one</code> and <code class="language-plaintext highlighter-rouge">thing two</code> in the callback are beginning execution and are done synchronously immediately. I don’t know why I had a tendency(don’t know if others have too) to think all the code within the <code class="language-plaintext highlighter-rouge">Promise</code> constructor only begins executing as a whole at the settling point, the point when the <code class="language-plaintext highlighter-rouge">resolve</code> or <code class="language-plaintext highlighter-rouge">reject</code> are called. Realizing this is important for us to maintain the execution sequence of tasks and thinking about possible performance considerations.</p>

<p><strong>order of creation is not the guarantee of order of completion</strong></p>

<p>If we have a list of urls <code class="language-plaintext highlighter-rouge">[u1, u2, u3]</code> that don’t depend on each other, means they can be loaded in parallel. But we want to get things from the 3 urls one after another, in the order of <code class="language-plaintext highlighter-rouge">1,2,3</code>. We may write something like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">requestURL</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">u1</span><span class="p">,</span> <span class="nx">u2</span><span class="p">,</span> <span class="nx">u3</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">url</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">requestURL</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Although all the requests may succeed but the order of completion is not guaranteed. Why? Because <code class="language-plaintext highlighter-rouge">forEach</code> is sync and what we actually did can be seen as:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">requestURL</span><span class="p">(</span><span class="nx">u1</span><span class="p">);</span>
<span class="nx">requestURL</span><span class="p">(</span><span class="nx">u2</span><span class="p">);</span>
<span class="nx">requestURL</span><span class="p">(</span><span class="nx">u3</span><span class="p">);</span>
</code></pre></div></div>

<p>All <code class="language-plaintext highlighter-rouge">promise</code>s begin creating almost at the same time because the 3 function calls are executed synchronously, meanwhile all code within <code class="language-plaintext highlighter-rouge">Promise</code> constructor begins executing. <code class="language-plaintext highlighter-rouge">requestURL</code> returns a <code class="language-plaintext highlighter-rouge">promise</code>, but code written in <code class="language-plaintext highlighter-rouge">Promise</code> constructor won’t pause executing. So the 3 requests begins at almost the same time but we don’t know how much time each request would take, therefore we don’t know the order completion.</p>

<p><strong>there’s no waiting among multiple promises created independently</strong></p>

<p>Since a <strong>promise chain</strong> will be paused for <code class="language-plaintext highlighter-rouge">pending</code> promises, it’s easy to transfer this fact(feeling) to the situation when we create multiple <code class="language-plaintext highlighter-rouge">promise</code>s at one time, thinking that lately created <code class="language-plaintext highlighter-rouge">promise</code>s would wait for the earlier ones to be settled. But:</p>

<ul>
  <li>waiting happens when there’s <code class="language-plaintext highlighter-rouge">pending</code> promise in a chain. You can’t just make a <code class="language-plaintext highlighter-rouge">promise</code> independently then “pause” it there, neither from inside nor outside.</li>
  <li>a <code class="language-plaintext highlighter-rouge">pending</code> promise never pauses itself. When a promise is created, its original state is <code class="language-plaintext highlighter-rouge">pending</code>, but from an internal view, <code class="language-plaintext highlighter-rouge">pending</code> doesn’t mean pausing/waiting. As long as there is call for <code class="language-plaintext highlighter-rouge">resolve</code> or <code class="language-plaintext highlighter-rouge">reject</code> thereafter, a <code class="language-plaintext highlighter-rouge">pending</code> promise is approaching the state of <code class="language-plaintext highlighter-rouge">fulfilled</code> or <code class="language-plaintext highlighter-rouge">rejected</code>.</li>
</ul>

<p>So creating a bunch of <code class="language-plaintext highlighter-rouge">promise</code>s doesn’t mean the latter ones will wait for the earlier ones, doesn’t mean they be completed in the order of creation. Unless you wrap the process of creating promise inside a function(a function returns a <code class="language-plaintext highlighter-rouge">promise</code>), then arrange them in a chain. There is a big difference between “creating a promise” and “a function that creates a promise”. Because when we pass “a function that creates a promise” to <code class="language-plaintext highlighter-rouge">then()</code>, the creation of promise won’t start before the chain advances to that <code class="language-plaintext highlighter-rouge">then</code>.</p>

<p><strong>how to maintain sequence of operations</strong></p>

<p>How to chain the requests in a wanted sequence or say initiate them one after another? Also with <code class="language-plaintext highlighter-rouge">forEach</code>, but this time a bit different.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">chain</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resovle</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>

<span class="p">[</span><span class="nx">u1</span><span class="p">,</span> <span class="nx">u2</span><span class="p">,</span> <span class="nx">u3</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">url</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">chain</span> <span class="o">=</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">requestURL</span><span class="p">(</span><span class="nx">url</span><span class="p">));</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Notice <code class="language-plaintext highlighter-rouge">chain.then(() =&gt; requestURL(url))</code> is different from <code class="language-plaintext highlighter-rouge">chain.then(requestURL(url))</code>,  <code class="language-plaintext highlighter-rouge">requestURL(url)</code> is a function invocation that will create a <code class="language-plaintext highlighter-rouge">promise</code> immediately, you should always pass a <em>function</em> to <code class="language-plaintext highlighter-rouge">then()</code>.</p>

<h4 id="23-resolve-happens-immediately">2.3 <code class="language-plaintext highlighter-rouge">resolve</code> happens immediately</h4>

<p>The same example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fetchURL</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// returns promise</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">suburl</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">suburl</span><span class="p">);</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This is a tricky point. The <code class="language-plaintext highlighter-rouge">resolve</code> method don’t know how much time a request would take. We call <code class="language-plaintext highlighter-rouge">resolve</code> in <code class="language-plaintext highlighter-rouge">Promise</code> constructor, and that happens inside the <code class="language-plaintext highlighter-rouge">'load'</code> event listener. Here <code class="language-plaintext highlighter-rouge">resolve(suburl)</code> has no notion about <code class="language-plaintext highlighter-rouge">sync/async</code> it’s called immediately when the request is <code class="language-plaintext highlighter-rouge">'load'</code>ed, and calling <code class="language-plaintext highlighter-rouge">resolve(suburl)</code> grants the state <code class="language-plaintext highlighter-rouge">fulfilled</code> to the promise with <code class="language-plaintext highlighter-rouge">suburl</code> as its value to prepare for possible future operations. And resolving of a promise is synchronous or say happens instantly.</p>

<p>This may seem obvious after you’ve noticed it. But realizing this fact can fill some mental gaps while trying to understand the using of promise. Since promise is heavily about “async”, it’s easy to forget that there’re also “sync” things there. It’s easy to grumble questions like “how does the promise know when to resolve itself”, the answer is it doesn’t know. Because the “resolving” moment depends on something else such as explicit writing sync code to resolve the <code class="language-plaintext highlighter-rouge">promise</code>, like <code class="language-plaintext highlighter-rouge">Promise.resolve()</code> or call <code class="language-plaintext highlighter-rouge">resolve</code> in a <code class="language-plaintext highlighter-rouge">Promise</code> constructor.</p>

<p>To me “<code class="language-plaintext highlighter-rouge">resolve</code> happens immediately” is a very useful nonsense.</p>

<h4 id="24-function-is-the-only-currency-within-a-promise-chain">2.4 function is the only currency within a promise chain</h4>

<p>I think initially we all know that <code class="language-plaintext highlighter-rouge">then</code> takes functions as arguments after we learned about the definition and use of promise. But as days roll on, we may want to stuff anything inside that pair of parentheses <code class="language-plaintext highlighter-rouge">()</code> followed by <code class="language-plaintext highlighter-rouge">then</code>. Especially things that are not function.</p>

<p><a href="https://github.com/promises-aplus/promises-spec">Promise/A+ spec</a> also mentions that <code class="language-plaintext highlighter-rouge">then</code> must return a promise and if <code class="language-plaintext highlighter-rouge">onFulfilled</code> <em>is not a function</em>, a <code class="language-plaintext highlighter-rouge">then</code> called on a resolved promise must return a new promise resolved with the value of the previous promise. It’s better to be expressed by code:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">resolvedPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">One</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">resolvedPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>Line 1 returns a promise resolved with “One”, but line 2 returns a new <code class="language-plaintext highlighter-rouge">promise</code>: <code class="language-plaintext highlighter-rouge">Promise {&lt;fulfilled&gt;: "One"}</code> resolved with <code class="language-plaintext highlighter-rouge">"One"</code> NOT <code class="language-plaintext highlighter-rouge">"Two"</code>. The string <code class="language-plaintext highlighter-rouge">"Two"</code> we pass the <code class="language-plaintext highlighter-rouge">then()</code> is ignored.</p>

<p>If we make a promise chain with several non-functions inserted for example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">resolvedPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">func</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">non</span><span class="o">-</span><span class="nx">func</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">func</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">non</span><span class="o">-</span><span class="nx">func</span><span class="p">)</span>
</code></pre></div></div>

<p>We can imagine that we strikethrough the <code class="language-plaintext highlighter-rouge">.then(non-func)</code> parts like:</p>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gig7q4l7irj32a407w3zv.jpg" alt="" /></p>

<p>Some call this “promise fall through”. What if one of the <code class="language-plaintext highlighter-rouge">non-func</code> is a <code class="language-plaintext highlighter-rouge">promise</code>? You may think the promise chain won’t ignore a <code class="language-plaintext highlighter-rouge">promise</code>. Let’s try by code:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">resolvedPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">I was resolved</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">starterPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">I am the starter promise.</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">starterPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolvedPromise</span><span class="p">);</span>
<span class="c1">// Promise {&lt;fulfilled&gt;: "I am the starter promise."}</span>
</code></pre></div></div>

<p>The last line returns <code class="language-plaintext highlighter-rouge">Promise {&lt;fulfilled&gt;: "I am the starter promise."}</code>, the resolved value of the <code class="language-plaintext highlighter-rouge">resolvedPromise</code> we passed to <code class="language-plaintext highlighter-rouge">then()</code> was not taken. So there’s no exception for this rule. <em>Function is the only currency within a promise chain</em>. If you want to insert a <code class="language-plaintext highlighter-rouge">promise</code> into a promise chain, use a function that returns a <code class="language-plaintext highlighter-rouge">promise</code>.</p>

<h4 id="25-two-kinds-of-waiting-on-promises">2.5 two kinds of waiting on promises</h4>

<p>Personally I prefer to understand that there’re actually two kinds of waiting for a <code class="language-plaintext highlighter-rouge">pending</code> promise. One is wait from “outside”, the other is wait from “inside”.</p>

<p>Wait from inside” means inside a <code class="language-plaintext highlighter-rouge">Promise</code> constructor, after a <code class="language-plaintext highlighter-rouge">promise</code> is created, it’s initially set to <code class="language-plaintext highlighter-rouge">pending</code>, and then it’s waiting to be either fulfilled or rejected. This kind of waiting is often neglected. On the contrary, the waiting made by <code class="language-plaintext highlighter-rouge">then()</code> is stressed a lot, and this is “wait from outside”. <em>Both kinds of waitings wait on a <code class="language-plaintext highlighter-rouge">promise</code> to transit from <code class="language-plaintext highlighter-rouge">pending</code> to <code class="language-plaintext highlighter-rouge">fulfilled/rejected</code></em>, but they are different. Having a notion of this helped me better understand the states of promise as well as the behavior of a promise chain.</p>

<h5 id="251-how-to-make-a-pending-promise">2.5.1 how to make a <code class="language-plaintext highlighter-rouge">pending</code> promise?</h5>

<p>This is fun and easy. Remember I said when trying to create a <code class="language-plaintext highlighter-rouge">promise</code> always consider <code class="language-plaintext highlighter-rouge">Promise</code> constructor? So the answer of this is “just make it but don’t resolve it”. That is:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">pendingPromise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span> <span class="c1">// Promise {&lt;pending&gt;}</span>
</code></pre></div></div>

<p>By doing this we get a pending promise <code class="language-plaintext highlighter-rouge">Promise {&lt;pending&gt;}</code> since we don’t call <code class="language-plaintext highlighter-rouge">resolve()</code> or <code class="language-plaintext highlighter-rouge">reject()</code> at all inside the callback. Another theoretically possible scenario is we called <code class="language-plaintext highlighter-rouge">resolve()</code> or <code class="language-plaintext highlighter-rouge">reject()</code> but the time before that happens was “forever”. For example, <code class="language-plaintext highlighter-rouge">resolve()</code> or <code class="language-plaintext highlighter-rouge">reject()</code> is waiting to be called after a data retrieving task that never ends.</p>

<h5 id="252-pauses-on-thens-are-visible">2.5.2 pauses on <code class="language-plaintext highlighter-rouge">then</code>s are “visible”</h5>

<p>Now if we have a <code class="language-plaintext highlighter-rouge">pending</code> promise, let’s see how the chain will pause:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">pendingPromise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span> <span class="c1">// Promise {&lt;pending&gt;}</span>

<span class="nx">pendingPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello World.</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// Not words printed out</span>
            <span class="c1">//  ^</span>
            <span class="c1">//paused</span>
</code></pre></div></div>

<p>Since <code class="language-plaintext highlighter-rouge">pendingPromise</code> is at the state of <code class="language-plaintext highlighter-rouge">pending</code>, the next <code class="language-plaintext highlighter-rouge">then</code> will wait on it. I often see words like “waiting on a promise”, though this is not wrong, but this gives us a sense that where there is a promise there is a waiting. But waiting only happens on <code class="language-plaintext highlighter-rouge">pending</code> promise.</p>

<h5 id="253-then-only-waits-on-pending-promises-doesnt-mean-settled-ones-are-skipped">2.5.3 <code class="language-plaintext highlighter-rouge">then()</code> only waits on <code class="language-plaintext highlighter-rouge">pending</code> promises doesn’t mean settled ones are skipped</h5>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">one</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// Promise {&lt;fulfilled&gt;: "two"}</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">one</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">)).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">three</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// Promise {&lt;fulfilled&gt;: "three"}</span>
</code></pre></div></div>

<p>Here both lines start with a <code class="language-plaintext highlighter-rouge">promise</code> resolved with <code class="language-plaintext highlighter-rouge">"one"</code>. When we chain one <code class="language-plaintext highlighter-rouge">then</code> we get a new <code class="language-plaintext highlighter-rouge">promise</code> resolved with <code class="language-plaintext highlighter-rouge">"two"</code>. When chain two <code class="language-plaintext highlighter-rouge">then</code>s we get a new <code class="language-plaintext highlighter-rouge">promise</code> resolved with <code class="language-plaintext highlighter-rouge">"three"</code>. Based on line 1 we know there is a “middle promise” with “two” as its value existed transitorily. But no <code class="language-plaintext highlighter-rouge">promise</code> is skipped even through they are resolved ones.</p>

<p>If we configure a promise chain appropriately, of course the chain will wait on <code class="language-plaintext highlighter-rouge">pending</code> promises, but the chain also won’t forget to go through every <code class="language-plaintext highlighter-rouge">fulfilled</code> or <code class="language-plaintext highlighter-rouge">rejected</code> ones.</p>

<h3 id="3-try-to-nurture-intimacy-with-standard">3 Try to nurture intimacy with standard</h3>

<p>This is more of a suggestion than another key point, but I think it’s important for learning promise too.
If you’ve ever explored some articles about promise, you may have been introduced with the <a href="https://promisesaplus.com/">Promise/A+</a> standard, I mentioned it several times in this article. As it states, it’s:</p>

<blockquote>
  <p>An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.</p>
</blockquote>

<p>In that page, there are just several sections of structured rules. So promise is more of a model, it’s not some hard-coded packages. The rules describe how to implement promise, but there doesn’t exist a single right way to implement it. This is very similar to what we talk about the mental model of event loop. Actually if you have known the basic aspects of promise and are using the correct terms, reading the standard is more helpful when you are confused by “promise puzzles”. The standard is really boring, but it’s also very reliable.</p>

<h3 id="4-summary">4 Summary</h3>

<p>In this 2-part article, I think the important takeaway are:</p>

<ul>
  <li>the separation of async and sync is for better coordinating different tasks, and event loop model is one way to do the coordinating work.</li>
  <li>differentiate sync and async part when using promise; there are two kinds of wait for a pending promise; function is the only currency in a promise chain.</li>
  <li>try to nurture intimacy with standards and docs.</li>
</ul>

<p>We’ve been through a long journey from setTimeout to Promise. In part 1, we spend most time discussing what is sync and async, and how they are coordinated by the event loop model. Although we barely mentioned promise in part 1 but all the discussion there will support our understanding of promise. In this part 2, I don’t write about how to use promise, instead I focus on some key points that may be missed during the process of learning promise. Hope this can help you a bit on the journey of exploring promise.</p>

<hr />

<p><em>References:</em></p>

<p>https://web.dev/promises/</p>

<p>https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</p>

<p>https://en.wikipedia.org/wiki/Futures_and_promises</p>

<p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise</p>

<p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</p>

<p>https://promisesaplus.com/</p>

<p>https://stackoverflow.com/questions/31324110/why-does-the-promise-constructor-require-a-function-that-calls-resolve-when-co</p>

<p>https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises</p>

        </div>

        
          <div class="page-share">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fpromise2-key-points%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--facebook btn--small"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> <span>Share</span></a>
  <a href="https://twitter.com/intent/tweet?text=On+exploring+Promise+2%3A+possible+overlooked+points+about+promise%20http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fpromise2-key-points%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--twitter btn--small"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> <span>Tweet</span></a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fpromise2-key-points%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--linkedin btn--small"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> <span>LinkedIn</span></a>
  <a href="https://reddit.com/submit?title=On+exploring+Promise+2%3A+possible+overlooked+points+about+promise&url=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fpromise2-key-points%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--reddit btn--small"><i class="fab fa-fw fa-reddit" aria-hidden="true"></i> <span>Reddit</span></a>
</div>

        

        

        <nav class="page-pagination" role="navigation">
  
    <a class="page-previous" href="/work/promise1-async-and-event-loop/">
      <h4 class="page-pagination-label">Previous</h4>
      <span class="page-pagination-title">
        <i class="fas fa-arrow-left"></i> On exploring Promise 1: thoughts about async and event loop model

      </span>
    </a>
  

  
</nav>

      </div>
    </div>
  </article>
</main>


    <footer id="footer" class="site-footer">
  <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
<div class="social-icons"><a class="social-icon" href="/atom.xml"><i class="fas fa-rss-square fa-2x" title="Feed"></i></a></div><div class="copyright">
    
      <p>&copy; 2020 Xullnn's words. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/mmistakes/so-simple-theme" rel="nofollow">So Simple</a>.</p>
    
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>


  </body>

</html>
