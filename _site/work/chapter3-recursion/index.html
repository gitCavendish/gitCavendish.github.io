<!DOCTYPE html>
<!--
    So Simple Jekyll Theme 3.2.0
    Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
-->
<html lang="en-US" class="no-js">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Algorithms 101 - 3 - recursion | Xullnn’s words</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Algorithms 101 - 3 - recursion" />
<meta name="author" content="Xullnn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容" />
<meta property="og:description" content="算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容" />
<link rel="canonical" href="http://localhost:4000/work/chapter3-recursion/" />
<meta property="og:url" content="http://localhost:4000/work/chapter3-recursion/" />
<meta property="og:site_name" content="Xullnn’s words" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Algorithms 101 - 3 - recursion" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@Xullnn" />
<script type="application/ld+json">
{"datePublished":"2018-04-25T00:00:00+08:00","headline":"Algorithms 101 - 3 - recursion","dateModified":"2018-04-25T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/work/chapter3-recursion/"},"url":"http://localhost:4000/work/chapter3-recursion/","author":{"@type":"Person","name":"Xullnn"},"description":"算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  

  <script>
    /* Cut the mustard */
    if ( 'querySelector' in document && 'addEventListener' in window ) {
      document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + 'js';
    }
  </script>

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/skins/dark.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i|Lora:400,400i,700,700i">
  <link rel="alternate" type="application/atom+xml" title="Xullnn&#39;s words" href="/atom.xml">
<!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

</head>


  <body class="layout--post  algorithms-101-3-recursion">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#primary-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    
  <div class="navigation-wrapper">
    <a href="#menu-toggle" id="menu-toggle">Menu</a>
    <nav id="primary-nav" class="site-nav animated drop">
      <ul><li><a href="/">Home</a></li><li><a href="/categories/">Categories</a></li><li><a href="/tags/">Tags</a></li><li><a href="/search/">Search</a></li></ul>
    </nav>
  </div><!-- /.navigation-wrapper -->


    <header class="masthead">
  <div class="wrap">
    
    
    
      
        <div class="site-title animated fadeIn"><a href="/">Xullnn's words</a></div>
      
      <p class="site-description animated fadeIn" itemprop="description">You can't do much carpentry with your bare hands and you can't do much thinking with your bare brain.</p>
    
  </div>
</header><!-- /.masthead -->


    <main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

    <div class="page-wrapper">
      <header class="page-header">
        
        
          <h1 id="page-title" class="page-title p-name">Algorithms 101 - 3 - recursion
</h1>
        
      </header>

      <div class="page-sidebar">
        <div class="page-author h-card p-author"><img src="/images/2020.jpg" class="author-avatar u-photo" alt="Xullnn"><div class="author-info"><div class="author-name">
        <em>by</em> <span class="p-name">Xullnn</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href=""><i class="fas fa-link fa-lg" title=""></i></a>
          </li></ul>

<span class="read-time">3 min read</span>

    <time class="page-date dt-published" datetime="2018-04-25T00:00:00+08:00"><a class="u-url" href="">April 25, 2018</a>
</time>

  </div>
</div>

        
  <h3 class="page-taxonomies-title">Categories</h3>
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="/categories/#work" title="Pages filed under Work">Work</a></li>
  </ul>


        
  <h3 class="page-taxonomies-title">Tags</h3>
  <ul class="page-taxonomies"><li class="page-taxonomy"><a href="/tags/#programming" title="Pages tagged programming" rel="tag">programming</a></li><li class="page-taxonomy"><a href="/tags/#algorithm" title="Pages tagged algorithm" rel="tag">algorithm</a></li><li class="page-taxonomy"><a href="/tags/#%E7%AE%97%E6%B3%95" title="Pages tagged 算法" rel="tag">算法</a></li><li class="page-taxonomy"><a href="/tags/#reading-notes" title="Pages tagged reading notes" rel="tag">reading notes</a></li>
  </ul>


      </div>

      <div class="page-content">
        <div class="e-content">
          <p><em>算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容</em></p>

<h3 id="主要内容">主要内容</h3>

<ul>
  <li>Recursion is when a function calls itself.    <br />
递归是一种会call到自身的函数</li>
  <li>Every recursive function has two cases: the base case and the recursive case.    <br />
每一个递归函数都有两种case: base case 和 递归case</li>
  <li>A stack has two operations: push and pop.   <br />
针对堆栈的操作有两种： push 和 pop</li>
  <li>All function calls go onto the call stack.
所有函数呼叫都会在这个呼叫的 call stack 上</li>
  <li>The call stack can get very large, which takes up a lot of memory.   <br />
当call stack 变得非常长的时候，会占用很多的内存</li>
</ul>

<hr />

<p>Recursion中文译作递归。是很多算法中都会用到的编程技术。</p>

<blockquote>
  <p>Many important algorithms use recursion, so it’s important to understand the concept.</p>
</blockquote>

<hr />

<h4 id="1-recursion-is-when-a-function-calls-itself">1 Recursion is when a function calls itself.</h4>

<p>Recursion function/method 是指那些会在自身内部再次call到方法本身的 function/method.</p>

<p>书中给的从嵌套箱子中找钥匙的例子有点让人疑惑。直接用一个简单的代码(用ruby)示例说明：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_sum</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">list</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="nf">shift</span> <span class="o">+</span> <span class="n">recursive_sum</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="c1"># 这里就call回到自己本身</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">recursive_sum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>拆开一步一步看：</p>

<p>recursive_sum [1,2,3,4] (第1步)</p>
<ul>
  <li>else: return 1 + recursive_sum([2,3,4]) (return 并没有完成，挂起，进入recursion第2步)
    <ul>
      <li>recursive_sum [2,3,4]
        <ul>
          <li>else: return 2 + recursive_sum([3,4]) (return 并没有完成，挂起，进入recursion第3步)
            <ul>
              <li>recursive_sum [3,4]
                <ul>
                  <li>else: return 3 + recursive_sum([4]) (return 并没有完成，挂起，进入recursion第4步)
                    <ul>
                      <li>recursive_sum [4]
                        <ul>
                          <li>else: return 4 + recursive_sum([]) (return 并没有完成，挂起，进入recursion第5步)
                            <ul>
                              <li>recursive_sum []
                                <ul>
                                  <li>if: return 0, 这一步 return 完成，上一步第5步中被挂起的 <code class="language-plaintext highlighter-rouge">recursive_sum([])</code> 返回0</li>
                                </ul>
                              </li>
                              <li>第5步中 return (4 + 0) = 4, 第4步中的 <code class="language-plaintext highlighter-rouge">recursive_sum([4])</code> 拿到结果 4</li>
                            </ul>
                          </li>
                          <li>第4步中 return (3 + 4) = 1, 第3步中的 <code class="language-plaintext highlighter-rouge">recursive_sum([3,4])</code> 拿到结果 7</li>
                        </ul>
                      </li>
                      <li>第3步中 return (2 + 7) = 1, 第2步中的 <code class="language-plaintext highlighter-rouge">recursive_sum([2,3,4])</code> 拿到结果 9</li>
                    </ul>
                  </li>
                  <li>第2步中 return (1 + 9) = 10, 第1步中的 <code class="language-plaintext highlighter-rouge">recursive_sum([1,2,3,4])</code> 拿到结果 10</li>
                </ul>
              </li>
              <li>第1步中 else 分支的 return <strong>拿到最终结果 10</strong>， 退出function。</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-every-recursive-function-has-two-cases-the-base-case-and-the-recursive-case">2 Every recursive function has two cases: the base case and the recursive case.</h4>

<p><strong>base case：</strong> 即设定好的让 recursion 能在最后停下来的条件。上面例子中就是 if 分支对应的代码</p>

<p><strong>recursive case:</strong> 即设定好的让recursion继续循环下去的条件。上面例子中即是 else 分支对应的代码，能让recursion逐渐收拢或说base case靠近。</p>

<p><a href="https://en.wikipedia.org/wiki/Recursion#base_case">wikipedia中recursion的定义</a></p>

<blockquote>
  <p>In mathematics and computer science, a class of objects or methods exhibit recursive behavior when they can be defined by two properties:  <br />
A simple <strong>base case</strong> (or cases)—a terminating scenario that does not use recursion to produce an answer   <br />
（recursive case）A set of rules that reduce all other cases toward the base case</p>
</blockquote>

<p>base case对应的中文理解最好不是’基础条件’或’基本条件’, 我倾向于理解为’触底条件’，这样容器理解他实际是一个临界条件/状态，是stack堆到最高处即将开始回归的点。</p>

<h4 id="3-the-call-stack-in-recursion">3 The call stack in Recursion</h4>

<p>可以使用视觉化的方式来理解call stack。将其想象为一个不断累加的积木，来看上面代码实例的call stack结构。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">第1步</th>
      <th style="text-align: center">第2步</th>
      <th style="text-align: center">第3步</th>
      <th style="text-align: center">第4步</th>
      <th style="text-align: center">第5步</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum []</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [4]</td>
      <td style="text-align: center">recursive_sum [4]</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [3,4]</td>
      <td style="text-align: center">recursive_sum [3,4]</td>
      <td style="text-align: center">recursive_sum [3,4]</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
    </tr>
    <tr>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
    </tr>
  </tbody>
</table>

<p>可以看到从第一层开始，call stack逐层堆叠，其中每一层存在的call stack都说明这个function/method还未完成，处于挂起状态。</p>

<p>在第5步时触及 base case 后，call stack 不会再向上堆叠。而是向下回归，逐步完成每一步被挂起的 function/method。就像把积木一个一个逐层拿下来。也就是call stack最上层的funciton/method执行完之后，下面的才能相继得以完成。</p>

<p>wikipedia 上 stack 的示意图</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/Lifo_stack.png" alt="" /></p>

<p><strong>需要注意的是在整个 call stack 中，function/method 之间可以传递对象</strong>， 上面例子中则是用于计算的那个 array</p>

<blockquote>
  <p>This is the big idea behind this section: when you call a function from another function, the calling function is paused in a partially completed state. All the values of the variables for that function are still stored in memory.”</p>
</blockquote>

<h4 id="4-stack-的得与失">4 stack 的得与失</h4>

<p>使用 stack 的一个风险是，可能会用掉很多的内存，当stack堆叠层数很多时，每一步都被挂起，每一步都要存储信息，这就可能导致占用很多内存。两种解决方法：</p>

<p>1 使用 loop 而不用 recursive 的写法</p>

<p>2 使用 <code class="language-plaintext highlighter-rouge">trail recursion</code> 方法，这个方法超出本书讨论范围，而且只能在某些语言中使用。</p>

<p>** Loop 与 Recursion **</p>

<p>上面array求和的例子使用loop也可以做到：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">loop_sum</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
  <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">.</span><span class="nf">length</span>
    <span class="n">acc</span> <span class="o">+=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">acc</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这引出了什么情况使用 loop 什么情况使用 recursion 这个问题。实际情况是处理相同的任务loop可能更节省内存（变量一直在动态变化，而不是每个循环都要存，也不会有多个function/method挂起），recursive fucntion/method 比较易读。书上给出了一个 Stackoverflow 上的答案。</p>

<p>https://stackoverflow.com/questions/72209/recursion-or-iteration/72694</p>

<blockquote>
  <p>Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!</p>
</blockquote>

<p>很多重要的算法使用 recursion 所以理解他的概念很重要 – Recursion is when a function calls itself.</p>

<h4 id="5-all-function-calls-go-onto-the-call-stack">5 All function calls go onto the call stack</h4>

<p>所有函数的呼叫都会进入调用堆栈。</p>

<p>书中对此没有详细解释，我的理解是，实际我们在写一个函数的时候，在其内部不出意料地会用到其他函数，有些很基础的函数可能都没意识到，比如 <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">==</code> 或者如 <code class="language-plaintext highlighter-rouge">delete</code> <code class="language-plaintext highlighter-rouge">push</code> 等。至少在Ruby中，同一个名称的method在不同Class中可能有不同的处理方式，比如从一个string中delete一个字母和从array中delete一个element肯定是不同的。 所以这些基本的函数也可以算作stack中的一层。</p>

<hr />

<h4 id="recap">recap:</h4>

<ul>
  <li>Recursion is when a function calls itself</li>
  <li>Every recursive function has two cases: the base case and the recursive case</li>
  <li>A stack has two operations: push and pop (这个push不是array中的从尾部注入，而是在stack顶端叠加一层，pop则是拿掉最顶上的那层)</li>
  <li>All function calls go onto the call stack 所有函数的调用都会进入调用堆栈</li>
  <li>The call stack can get very large, which takes up a lot of memory</li>
</ul>

<hr />

<p>Exercise 3.1</p>

<p>Suppose I show you a call stack like this.</p>

<p>What information can you give me, just based on this call stack?</p>

<p>Now let’s see the call stack in action with a recursive function.</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-17+%E4%B8%8B%E5%8D%8811.35.57.png" alt="" /></p>

<p>greet function 先被叫到，带着变数name； 接着greet2也带着变数name被叫到；在当前时刻greet是挂起的未完成状态；当前位置是在 greet2 中；在greet2执行完后，greet 将会继续执行</p>

<p>3.2</p>

<p>Suppose you accidentally write a recursive function that runs forever. As you saw, your computer allocates memory on the stack for each function call. What happens to the stack when your recursive function runs forever?</p>

<p>stack会一直叠加。</p>

        </div>

        
          <div class="page-share">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fchapter3-recursion%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--facebook btn--small"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> <span>Share</span></a>
  <a href="https://twitter.com/intent/tweet?text=Algorithms+101+-+3+-+recursion%20http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fchapter3-recursion%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--twitter btn--small"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> <span>Tweet</span></a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fchapter3-recursion%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--linkedin btn--small"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> <span>LinkedIn</span></a>
  <a href="https://reddit.com/submit?title=Algorithms+101+-+3+-+recursion&url=http%3A%2F%2Flocalhost%3A4000%2Fwork%2Fchapter3-recursion%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--reddit btn--small"><i class="fab fa-fw fa-reddit" aria-hidden="true"></i> <span>Reddit</span></a>
</div>

        

        

        <nav class="page-pagination" role="navigation">
  
    <a class="page-previous" href="/work/chapter2-selection-sort/">
      <h4 class="page-pagination-label">Previous</h4>
      <span class="page-pagination-title">
        <i class="fas fa-arrow-left"></i> Algorithms 101 - 2 - selection sort

      </span>
    </a>
  

  
    <a class="page-next" href="/work/chapter4-quick-sort/">
      <h4 class="page-pagination-label">Next</h4>
      <span class="page-pagination-title">
        Algorithms 101 - 4 - quicksort
 <i class="fas fa-arrow-right"></i>
      </span>
    </a>
  
</nav>

      </div>
    </div>
  </article>
</main>


    <footer id="footer" class="site-footer">
  <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
<div class="social-icons"><a class="social-icon" href="/atom.xml"><i class="fas fa-rss-square fa-2x" title="Feed"></i></a></div><div class="copyright">
    
      <p>&copy; 2020 Xullnn's words. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/mmistakes/so-simple-theme" rel="nofollow">So Simple</a>.</p>
    
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>


  </body>

</html>
